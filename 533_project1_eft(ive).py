# -*- coding: utf-8 -*-
"""533_Project1_EFT(IVE).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ge2RFw0fEQ_Bvi1Ih1CEHZp63LbDieEW
"""

import yfinance as yf
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec

####################################################
"""
(1) Analyze the ETF returns without any risk adjustments. Describe the summary statistics of returns. Comment on what you observe.
"""
####################################################

def plot_price(ticker, start_date):
    # Download stock data from Yahoo Finance
    stock_data = yf.download(ticker, start=start_date, interval='1mo')

    # Resample data to monthly frequency
    stock_data['Returns'] = stock_data['Adj Close'].pct_change().dropna()

    # Define the figure with custom style
    plt.figure(figsize=(10, 5), facecolor='lightblue', edgecolor='darkblue', linewidth=8)
    plt.plot(stock_data['Adj Close'], label='Adjusted Close', color='red')

    # Define font styles
    font1 = {'family':'serif', 'color':'blue', 'size':25}
    font2 = {'family':'serif', 'color':'darkblue', 'size':15}

    # Set title and labels with the specified font dictionaries
    plt.title(f'{ticker} Stock Price Over Time', fontdict=font1, fontweight='bold')
    plt.xlabel('Date', fontdict=font2, fontweight='bold', labelpad=30)
    plt.ylabel('Stock Price', fontdict=font2, fontweight='bold', labelpad=30)

    # Show legend and grid
    plt.legend()
    plt.grid(linestyle='dotted', color='lightskyblue')
    plt.show()

plot_price("IVE", "2000-01-01")

def calculate_monthly_returns(ticker, start_date):
    # Download stock data from Yahoo Finance
    stock_data = yf.download(ticker, start=start_date, interval='1mo')

    # Calculate monthly returns
    stock_data['Returns'] = stock_data['Adj Close'].pct_change().dropna()

    # Summary statistics
    summary_stats = stock_data['Returns'].describe()

    return stock_data['Returns'], summary_stats

def plot_monthly_returns_with_custom_style_and_summary(ticker, start_date):
    # Calculate monthly returns and get summary statistics
    monthly_returns, summary_stats = calculate_monthly_returns(ticker, start_date)

    # Define font styles
    font1 = {'family':'serif', 'color':'blue', 'size':25}
    font2 = {'family':'serif', 'color':'darkblue', 'size':15}

    # Create a figure with custom GridSpec layout
    fig = plt.figure(figsize=(15, 5), facecolor='lightblue',edgecolor='darkblue', linewidth=8)
    gs = GridSpec(1, 2, width_ratios=[3, 1])  # Adjust the width ratio here

    ax1 = fig.add_subplot(gs[0])
    ax2 = fig.add_subplot(gs[1])

    # Plot settings for monthly returns
    ax1.plot(monthly_returns.index, monthly_returns, label='Monthly Returns', color='red')
    ax1.set_title(f'{ticker} Monthly Returns', fontdict=font1, fontweight='bold')
    ax1.set_xlabel('Date', fontdict=font2, fontweight='bold')
    ax1.set_ylabel('Monthly Returns (%)', fontdict=font2, fontweight='bold')
    ax1.legend()
    ax1.grid(linestyle='dotted', color='lightskyblue')

    # Display summary statistics
    ax2.axis('off')  # Turn off the axis
    summary_text = summary_stats.to_string()
    ax2.text(0.5, 0.5, summary_text, ha="center", va="center", fontsize=10, family='monospace', color='blue')

    plt.tight_layout()
    plt.show()

plot_monthly_returns_with_custom_style_and_summary("IVE", "2000-01-01")

"""

The summary statistics for the iShares S&P 500 Value ETF (IVE) monthly returns without any risk adjustments are as follows:

Count: 281 months of return data are available for analysis.
Mean: The average monthly return is approximately 0.65%, indicating a positive average return over the period analyzed.
Standard Deviation: The standard deviation is about 4.68%, which suggests a moderate level of volatility or risk in the returns.
Minimum: The lowest monthly return observed is -16.34%, showing the potential for significant short-term losses.
25th Percentile: 25% of the monthly returns are less than -1.88%, indicating that returns are negative in at least one quarter of the months.
Median: The median monthly return is 1.21%, which is the middle value separating the higher half from the lower half of the data sample.
75th Percentile: 75% of the monthly returns are less than 3.31%, showing that most of the returns are modest and not extremely high.
Maximum: The highest monthly return observed is 12.91%, reflecting the potential for significant short-term gains.

From these statistics, we can infer that the ETF has provided a positive return on average, with a relatively moderate level of volatility.
The range between the minimum and maximum returns suggests that while the ETF can have periods of significant gains, it can also experience substantial drops, which is typical behavior for equity investments.
The positive mean return indicates that the investment has generally grown over the period analyzed, but investors should be mindful of the potential for volatility and negative returns in any given month.​


"""

####################################################
"""
(2) In the spirit of seasonality, calculate the average return for each calendar month. Also,
– Identify the month with the maximum average return and test if it statistically different than other months.
– Identify the month with the minimum average return and test if it statistically different than other months.
"""
####################################################

import yfinance as yf
import pandas as pd
from datetime import date
import plotly.express as px

def Seasonality_Dynamic_Interactive(ticker, start=None, end=None):
    if start is None:
        start = "2020-01-01"
    if end is None:
        end = date.today()

    price = yf.download(ticker, start, end)
    df = pd.DataFrame({'return': price['Close'].pct_change().fillna(0)})

    months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June', 'July', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
    df = df[df.index >= df[df.index.month == 1].index[0]]
    df = df[df.index <= df[df.index.month == 12].index[-1]]

    # Monthly Data Summary
    monthly = {}
    for year in df.index.year.unique():
        yeardf = df[df.index.year == year]
        monthly[year] = yeardf.groupby(yeardf.index.month).sum() * 100

    data = pd.concat(monthly, axis=1)
    data.columns = [col[0] for col in data.columns]
    data.index = months
    summary = pd.DataFrame(data.mean(axis=1))
    summary.columns = ['Return %']
    summary = summary.reset_index().rename(columns={'index': 'Month'})

    # Create interactive Plotly graph with light blue theme and dark blue titles, axis labels
    fig = px.line(summary, x='Month', y='Return %', markers=True, title=f'Seasonal Chart: {ticker}',)
    fig.update_traces(line=dict(color='blue'), marker=dict(color='red', size=10))
    fig.update_layout(
        plot_bgcolor='lightblue',
        paper_bgcolor='lightblue',
        title_font=dict(color='darkblue', size=25),
        xaxis=dict(title='Month', title_font=dict(color='darkblue', size=18)),
        yaxis=dict(title='Return %', title_font=dict(color='darkblue', size=18))
    )
    fig.show()

    return data.T

Seasonality_Dynamic_Interactive("IVE", "2000-01-01")

"""
We observe that the periods yielding the highest returns typically occur in April (2.41%), July (1.24%), and November (2.48%), with November marking the peak.
Conversely, the most significant downturns are evident in June (-1.45%) and September (-1.61%), with September representing the lowest point.
Consequently, in updating our simple regression model from the previous project, we will incorporate these findings by treating the index as a variable within the function.
"""

# We need to add the additional library statsmodels at this point
import statsmodels.formula.api as smf

def simple_regression(ticker, month_index, start_date):
    stock_data = yf.download(ticker, start=start_date, interval='1mo')
    stock_data['Returns'] = stock_data['Adj Close'].pct_change()

    # Create a dummy variable for January
    stock_data['Selected_Month'] = (stock_data.index.month == month_index).astype(int)

    # Run regression
    model = smf.ols("Returns ~ Selected_Month", data = stock_data.dropna()).fit()

    # Print regression summary
    print(model.summary())

# check with November

simple_regression("IVE", 10, "2000-01-01")

"""

YORUM EKLENECEK OLS ÇIKTILARINA !!!!!

"""

# check with September

simple_regression("IVE", 9, "2000-01-01")

"""

YORUM EKLENECEK OLS ÇIKTILARINA !!!!!!

"""

####################################################
"""
(3) Using the risk factors estimate risk-adjusted alphas and comment on whether the ETF creates any value. Also,
– Comment on the risk factors you identified the ETF is exposed to. In other words, which risks does this ETF take?
– Explain how ETF returns would be affected from risk factors you identified above.
"""
####################################################

def test_factorsdata(etf_ticker, start):
    # Download ETF data and read factors data
    etf_data = yf.download(etf_ticker, start, interval='1mo')['Adj Close']
    factors_data = pd.read_csv("factors_data.csv", index_col='date', parse_dates=True, date_parser=lambda x: pd.to_datetime(x, format='%Y%m'))

    # Clean and merge data
    factors_data = factors_data.dropna(axis=1, how='all')
    merged_data = pd.merge(factors_data, etf_data, left_index=True, right_index=True).dropna()

    # Calculate returns and excess returns
    merged_data['Returns'] = merged_data['Adj Close'].pct_change() * 100
    merged_data['Excess'] = merged_data['Returns'] - merged_data['RF']
    merged_data = merged_data.drop(['Adj Close', 'year', 'month'], axis=1).dropna()

    # Fit the OLS model
    model = smf.ols('Excess ~ MktRF + SMB + HML + RMW + CMA + MOM', data=merged_data).fit()
    print(merged_data)
    print(model.summary())

test_factorsdata("IVE", "2000-01-01")

"""

YORUM EKLENECEK OLS ÇIKTILARINA !!!!!!

"""

####################################################
"""
(4) Using the industry portfolio returns estimate the ETF’s exposure to various industries. Comment on your findings. Also,
– Identify the largest industry exposure of the ETF and test whether this exposure is similar before and after 2019.
"""
####################################################

def test_industryrets(etf_ticker, start):
    # Download ETF data and read industry portfolios data
    etf_data = yf.download(etf_ticker, start, interval='1mo')['Adj Close']
    industry_data = pd.read_csv("industry_portfolios.csv", index_col='date', parse_dates=True, date_parser=lambda x: pd.to_datetime(x, format='%Y%m'))

    # Merge and calculate percentage returns
    merged_data = pd.merge(industry_data, etf_data, left_index=True, right_index=True, how='outer').dropna()
    merged_data['Returns'] = merged_data['Adj Close'].pct_change() * 100
    merged_data.drop(['Adj Close', 'year', 'month'], axis=1, inplace=True)
    merged_data.dropna(inplace=True)

    # Fit and print model
    formula = 'Returns ~ NoDur + Durbl + Manuf + Enrgy + HiTec + Telcm + Shops + Hlth + Utils + Other'
    complete_model = smf.ols(formula, data=merged_data).fit()
    print(complete_model.summary())

    # Create a dummy variable and fit the second model
    merged_data['post2019'] = (merged_data.index >= '2019-01-01').astype(int)
    model2019 = smf.ols("Returns ~ HiTec * post2019", data=merged_data).fit()
    print(model2019.summary())

test_industryrets('IVE', '2020-01-01')

"""

YORUM EKLENECEK OLS ÇIKTILARINA !!!!!!

"""